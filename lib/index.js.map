{"version":3,"file":"index.js","sources":["../node_modules/did-resolver/lib/resolver.modern.js","../src/index.ts"],"sourcesContent":["function t(){return(t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}).apply(this,arguments)}function e(){const t=new Map;return async(e,r)=>{var n;if(e.params&&\"true\"===e.params[\"no-cache\"])return await r();const a=t.get(e.didUrl);if(void 0!==a)return a;const i=await r();return\"notFound\"!==(null==(n=i.didResolutionMetadata)?void 0:n.error)&&t.set(e.didUrl,i),i}}function r(t,e){return e()}const n=new RegExp(\"^did:([a-zA-Z0-9_]+):([a-zA-Z0-9_.%-]+(:[a-zA-Z0-9_.%-]+)*)((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(/[^#?]*)?([?][^#]*)?(#.*)?$\");function a(t){if(\"\"===t||!t)return null;const e=t.match(n);if(e){const r={did:`did:${e[1]}:${e[2]}`,method:e[1],id:e[2],didUrl:t};if(e[4]){const t=e[4].slice(1).split(\";\");r.params={};for(const e of t){const t=e.split(\"=\");r.params[t[0]]=t[1]}}return e[6]&&(r.path=e[6]),e[7]&&(r.query=e[7].slice(1)),e[8]&&(r.fragment=e[8].slice(1)),r}return null}const i={didResolutionMetadata:{},didDocument:null,didDocumentMetadata:{}};function o(e){return async(r,n,a)=>{try{const o=await e(r,n,a);return t({},i,{didResolutionMetadata:{contentType:\"application/did+ld+json\"},didDocument:o})}catch(e){return t({},i,{didResolutionMetadata:{error:\"notFound\",message:e.toString()}})}}}class s{constructor(t={},n={}){this.registry=t,this.cache=!0===n.cache?e():n.cache||r,n.legacyResolvers&&Object.keys(n.legacyResolvers).map(t=>{this.registry[t]||(this.registry[t]=o(n.legacyResolvers[t]))})}async resolve(e,r={}){const n=a(e);if(null===n)return t({},i,{didResolutionMetadata:{error:\"invalidDid\"}});const o=this.registry[n.method];return o?this.cache(n,()=>o(n.did,n,this,r)):t({},i,{didResolutionMetadata:{error:\"unsupportedDidMethod\"}})}}export{s as Resolver,e as inMemoryCache,r as noCache,a as parse,o as wrapLegacyResolver};\n//# sourceMappingURL=resolver.modern.js.map\n","// import { decodeJWT } from 'did-jwt';\nimport { verifyPresentation, verifyCredential, VerifiablePresentation, VerifiableCredential } from 'did-jwt-vc';\nimport { Resolver, Resolvable } from 'did-resolver';\nimport { getResolver, ConfigurationOptions } from 'infra-did-resolver';\nimport InfraDID from 'infra-did-js';\n\nexport interface VerifierConfig {\n    resolver?: Resolvable\n    networkConfig: ConfigurationOptions\n    did: string\n    knownIssuer: string[]\n}\n\nexport type JWT = string\nexport type DID = string\n\nexport default class Verifier {\n    public resolver: Resolvable\n    public challenge: string\n    public did: string\n    public knownIssuer: string[]\n\n    constructor (config : VerifierConfig) {\n        this.resolver = config.resolver ? config.resolver : new Resolver(getResolver(config.networkConfig));\n        this.did = config.did ? config.did : InfraDID.createPubKeyDIDsecp256k1('01').did;\n        this.knownIssuer = config.knownIssuer;\n    }\n\n    public ready() : { challenge: string, aud: string } {\n        this.challenge = this.generateChallenge();\n        return { challenge: this.challenge, aud: this.did };\n    }\n\n    private generateChallenge() : string {\n        // use randomly generated DID as nonce for now\n        return InfraDID.createPubKeyDIDsecp256k1('01').did;\n    }\n\n    // public getVPClaims(vp: JWT) : any {\n    //     const vcList = decodeJWT(vp).payload.vp.verifiableCredential;\n    //     return vcList.map((vc) => {\n    //         return this.getVCClaims(vc);\n    //     }).reduce((result, claims) => {\n    //         return { ...claims, ...result }\n    //     }, {});\n    // }\n\n    // public getVCClaims(vc: JWT) : any {\n    //     return decodeJWT(vc).payload.vc.credentialSubject;\n    // }\n\n    // public async isValid(jwt: JWT) : Promise<boolean> {\n    //     const decoded = decodeJWT(jwt);\n    //     if (decoded.payload.vp) return this.isValidVP(jwt);\n    //     else if (decoded.payload.vc) return this.isValidVC(jwt);\n    //     else throw new Error (`Unsupported type`);\n    // }\n\n    public async isValidVP (vp: JWT) : Promise<boolean> {\n        // verify VP has been issued to the verifier with correct challenge\n        const verifiedPresentation = await verifyPresentation(vp, this.resolver, { challenge: this.challenge, audience: this.did })\n        const vcList = verifiedPresentation.payload.vp.VerifiedCredential;\n        const signer = verifiedPresentation.payload.signer;\n        if (this.isRevoked(signer.did)) throw new Error (`Deactivated Presenter`);\n        return vcList.map((vc) => {\n            return this.isValidVC(vc, signer.did);\n        }, this).reduce((result, validity) => {\n            return result && validity\n        }, true)\n    }\n\n    public async isValidVC (vc: JWT, holder?: DID) : Promise<boolean> {\n        // verify VC has NOT been tampered\n        const verifiedCredential = await verifyCredential(vc, this.resolver);\n        if (holder && verifiedCredential.payload.sub !== holder) throw new Error (`Signer is not the subject of VC`);\n\n        // verify the issuer identity is valid\n        if (this.isKnownIssuer(verifiedCredential.issuer)) throw new Error (`Unknown Issuer`);\n        \n        // verify the issuer identity has NOT been revoked\n        if (this.isRevoked(verifiedCredential.issuer)) throw new Error (`Deactivated Issuer`);\n        \n        // verify the VC has NOT been revoked\n        const vcID = verifiedCredential.payload.vc.id;\n        if (this.isRevoked(vcID)) throw new Error (`Revoked VC`);\n\n        return true;\n    }\n\n    public async isRevoked(did : DID) : Promise<boolean> {\n        const didDoc = await this.resolver.resolve(did);\n        if (didDoc.didDocumentMetadata.deactivated) return true;\n        return false;\n    }\n\n    public isKnownIssuer(issuer : DID) : boolean {\n        for (const key in this.knownIssuer) {\n            if (this.knownIssuer[key] === issuer) return true;\n        }\n        return false;\n    }\n}"],"names":["t","Object","assign","e","arguments","length","r","n","prototype","hasOwnProperty","call","apply","this","RegExp","a","match","did","method","id","didUrl","slice","split","params","path","query","fragment","i","didResolutionMetadata","didDocument","didDocumentMetadata","o","async","contentType","error","message","toString","s","[object Object]","registry","cache","Map","get","set","legacyResolvers","keys","map","config","resolver","Resolver","getResolver","networkConfig","InfraDID","createPubKeyDIDsecp256k1","knownIssuer","ready","challenge","generateChallenge","aud","isValidVP","vp","verifyPresentation","_this2","audience","verifiedPresentation","vcList","payload","VerifiedCredential","signer","isRevoked","Error","vc","isValidVC","reduce","result","validity","holder","verifyCredential","_this4","verifiedCredential","sub","isKnownIssuer","issuer","resolve","didDoc","deactivated","key"],"mappings":"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"}